@startuml PlantUML2Cpp

' set namespaceSeparator ::


class PlantUML2Cpp {
    bool run(filesystem::path path)
}

class Config {
    +string memberPrefix
    +string indent
    +bool noMemberPrefixForStructs
    +umap<string, string> containerByCardinalityComposition
    +umap<string, string> containerByCardinalityAggregation
    +umap<string, string> typeToIncludeMap
}

PlantUML2Cpp *-- "1" PlantUml.Parser
PlantUML2Cpp *-- "1" Cpp.Translator
PlantUML2Cpp *-- "1" Cpp.PostProcessor
PlantUML2Cpp *-- "1" Cpp.CodeGenerator
PlantUML2Cpp *-left- "1" Config

namespace PlantUml {

    interface AbstractVisitor {
        +visit(Variable v)     : bool
        +visit(Method m)       : bool
        +visit(Relationship r) : bool
        +visit(Container c)    : bool
        +visit(Element e)      : bool
        +visit(Note n)         : bool
        +visit(Separator s)    : bool
        +visit(Keyword k)      : bool
        +visit(Parameter p)    : bool
        +visit(End e)          : bool
    }

    class Parser {
        +parse(string_view input) : bool
        +showAST(AbstractVisitor visitor) : bool
    }

    class ModelElement << (V,#FF55AA) >>

    class Container {
        +name : list<string>
        +style : string
    }
    enum ContainerType {
        Document
        Package
        Namespace
    }

    class Element {
        +name : list<string>
        +stereotype : string
        +spotLetter : char
        +implements : list<string>
        +extends : list<string>
    }
    enum ElementType {
        Abstract
        Annotation
        Class
        Entity
        Enum
        Interface
    }

    class Variable {
        +name : string
        +type : Type
        +element : list<string>
    }
    class Method {
        +name : string
        +returnType : Type
        +element : list<string>
    }
    class Parameter {
        +name : string
        +type : Type
    }
    class Separator {
        +text : string
    }
    class Enumerator {
        +name : string
    }
    class Type
    {
        +list<string> base;
        +vector<Type> templateParams;
    }
    class Relationship {
        +subject : list<string> 
        +object : list<string> 
        +subjectCardinality : string 
        +objectCardinality : string 
        +label : string
        +hidden : bool
    }
    enum RelationshipType {
        Extension
        Composition
        Aggregation
        Usage
    }
    class Note {
        +name : string
        +relatesTo : list<string>
        +text : string
    }
    enum Visibility {
        Private
        Protected
        PackagePrivate
        Public
        Unspecified
    }
    enum Modifier {
        None
        Abstract 
        Static
    }
    class End
    enum EndType
    {
        Document
        Package
        Namespace
        Element
        Method
    }

    class SyntaxNode

    Parser *-- SyntaxNode : generate

    SyntaxNode *-- "0..*" SyntaxNode : children
    SyntaxNode *-- "1" ModelElement : element

    ModelElement *-up- Note
    ModelElement *-up- Separator
    ModelElement *-up- Enumerator
    ModelElement *-up- Parameter
    ModelElement *-up- Type
    ModelElement *-- Container
    ModelElement *-- Element
    ModelElement *-- Relationship
    ModelElement *-- Variable
    ModelElement *-- Method
    ModelElement *-- End

    Element *-- "1" ElementType : type
    Container *-- "1" ContainerType  : type
    Variable *-- "1" Visibility
    Variable *-- "1" Modifier
    Method *-- "1" Visibility
    Method *-- "1" Modifier
    End *-- "1" EndType : type
    Relationship *-- "1" RelationshipType : type

    AbstractVisitor -left-> ModelElement : visits

    Parser *-up- "1" peg_parser.SyntaxTree
    Parser *-up- "1" peg_parser.ParserGenerator
}

' TODO: go for Translator -> PostProcessor -> CodeGenerator

namespace Cpp {


    ' *************** DATA ***************

    class Class {
        +name : string
        +comment : string
        +isStruct : bool
        +namespaces : list<string>
        +inherits : set<string>
        +externalIncludes : vector<string>
        +localIncludes : vector<string>
    }
    class ClassElement << (V,#FF55AA) >>
    class VisibilityKeyword {
        +name : string
    }
    class Separator {
        +text : string
    }
    class Variable {
        +name : string
        +comment : string
        +isStatic : bool
    }
    class Method {
        +name : string
        +comment : string
        +isAbstract : bool
        +isConst : bool
        +isStatic : bool
    }
    class Parameter {
        +name : string
    }
    class Type
    {
        +list<string> base;
        +vector<Type> templateParams;
    }

    Method *-- "1" Type : returnType
    Parameter *-- "1" Type : type
    Variable *-- "1" Type : type


    Class *-- "0..*" ClassElement : body
    ClassElement *-- Method
    ClassElement *-- Variable
    ClassElement *-- VisibilityKeyword
    ClassElement *-- Separator
    Method *-- "0..*" Parameter : parameters


    class Enum {
        +name  : string
        +namespaces : list<string>
        +comment : string
    }
    class Keyword {
        +name : string
    }

    Enum *-- Keyword


    class Variant {
        +name  : string
        +namespaces : list<string>
        +comment : string
    }

    Variant *-- "1..*" Type : containedTypes


    class Types << (V,#FF55AA) >>
    Types *-- Class
    Types *-- Enum
    Types *-- Variant


    class Module {
        +name : string
    }
    Module *-- "0..*" Module
    Module *-- "0..*" Types


    ' *************** ALGORITHMS ***************
    class ClassTranslator {
        +visit(Variable v)     : bool
        +visit(Method m)       : bool
        +visit(Relationship r) : bool
        +visit(Element e)      : bool
        +visit(Note n)         : bool
        +visit(Separator s)    : bool
        +visit(Parameter p)    : bool

        +result() : Class
    }

    class ClassPostProcessor {
        +process(vector<Class>& classes)
    }

    class IncludeGatherer {
        +gather(Class& c)
    }
    class IncludeOptimizer {
        +process(vector<Class>& classes)
    }
    class MemberSorter {
        +sort(Class& c)
    }

    ClassPostProcessor *-- IncludeGatherer
    ClassPostProcessor *-- IncludeOptimizer
    ClassPostProcessor *--- MemberSorter
    IncludeOptimizer <- IncludeGatherer

    class ClassGenerator {
        +generate(Class c)
    }

    class HeaderGenerator {
        +string generate(Class in)
    }

    class SourceGenerator {
        +string generate(Class in)
    }

    ClassGenerator *-- HeaderGenerator
    ClassGenerator *-- SourceGenerator



    class Translator {
        +visit(Variable v)     : bool
        +visit(Method m)       : bool
        +visit(Relationship r) : bool
        +visit(Container c)    : bool
        +visit(Element e)      : bool
        +visit(Note n)         : bool
        +visit(Separator s)    : bool
        +visit(Keyword k)      : bool
        +visit(Parameter p)    : bool
        +visit(End e)          : bool

        +results() : Module
    }
    Translator --|> PlantUml.AbstractVisitor
    Translator *-- ClassTranslator

    class PostProcessor {
        process(Module m) : Module
    }
    PostProcessor *-- ClassPostProcessor

    class CodeGenerator {
        +generate(Module m)
    }
    CodeGenerator *-- ClassGenerator


    PostProcessor <- Translator
    CodeGenerator <- PostProcessor
}

@enduml