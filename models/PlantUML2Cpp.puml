@startuml PlantUML2Cpp

' set namespaceSeparator ::


class PlantUML2Cpp {
    bool run(filesystem::path path)
}

class Config << (S,#FFAA55) >>
{
    +string memberPrefix
    +string indent
    +bool noMemberPrefixForStructs
    +umap<string, string> containerByCardinalityComposition
    +umap<string, string> containerByCardinalityAggregation
    +umap<string, string> typeToIncludeMap
}

PlantUML2Cpp *-- "1" PlantUml.Parser
PlantUML2Cpp *-- Generator
PlantUML2Cpp *-left- "1" Config

class File << (S,#FFAA55) >>
{
    +path : path
    +content : string
}

interface Generator {
    generate(PlantUml.SyntaxNode root) : vector<File>
}
Generator -> File : uses

namespace PlantUml {

    interface AbstractVisitor {
        +visit(Variable v)     : bool
        +visit(Method m)       : bool
        +visit(Relationship r) : bool
        +visit(Container c)    : bool
        +visit(Element e)      : bool
        +visit(Note n)         : bool
        +visit(Separator s)    : bool
        +visit(Keyword k)      : bool
        +visit(Parameter p)    : bool
        +visit(End e)          : bool
    }

    class Parser 
    {
        +parse(string_view input) : bool
        +showAST(AbstractVisitor visitor) : bool
    }

    class ModelElement << (V,#FF55AA) >>

    class Container << (S,#FFAA55) >>
    {
        +name : list<string>
        +style : string
    }
    enum ContainerType {
        Document
        Package
        Namespace
    }

    class Element << (S,#FFAA55) >>
    {
        +name : list<string>
        +stereotype : string
        +spotLetter : char
        +implements : list<string>
        +extends : list<string>
    }
    enum ElementType {
        Abstract
        Annotation
        Class
        Entity
        Enum
        Interface
    }

    class Variable << (S,#FFAA55) >>
    {
        +name : string
        +type : Type
        +element : list<string>
    }
    class Method << (S,#FFAA55) >>
    {
        +name : string
        +returnType : Type
        +element : list<string>
    }
    class Parameter << (S,#FFAA55) >>
    {
        +name : string
        +type : Type
    }
    class Separator << (S,#FFAA55) >>
    {
        +text : string
    }
    class Enumerator << (S,#FFAA55) >>
    {
        +name : string
    }
    class Type << (S,#FFAA55) >>
    {
        +base : list<string>
        +templateParams : vector<Type>
    }
    class Relationship << (S,#FFAA55) >>
    {
        +subject : list<string> 
        +object : list<string> 
        +subjectCardinality : string 
        +objectCardinality : string 
        +label : string
        +hidden : bool
    }
    enum RelationshipType {
        Extension
        Composition
        Aggregation
        Usage
    }
    class Note << (S,#FFAA55) >>
    {
        +name : string
        +relatesTo : list<string>
        +text : string
    }
    enum Visibility {
        Private
        Protected
        PackagePrivate
        Public
        Unspecified
    }
    enum Modifier {
        None
        Abstract 
        Static
    }
    class End<< (S,#FFAA55) >>
    enum EndType
    {
        Document
        Package
        Namespace
        Element
        Method
    }

    class SyntaxNode << (S,#FFAA55) >>
    {
        +visit(AbstractVisitor visitor)
    }

    Parser *-- SyntaxNode : root

    SyntaxNode *-- "0..*" SyntaxNode : children
    SyntaxNode *-- "1" ModelElement : element

    ModelElement *-up- Note
    ModelElement *-up- Separator
    ModelElement *-up- Enumerator
    ModelElement *-up- Parameter
    ModelElement *-up- Type
    ModelElement *-- Container
    ModelElement *-- Element
    ModelElement *-- Relationship
    ModelElement *-- Variable
    ModelElement *-- Method
    ModelElement *-- End

    Element *-- "1" ElementType : type
    Container *-- "1" ContainerType  : type
    Variable *-- "1" Visibility
    Variable *-- "1" Modifier
    Method *-- "1" Visibility
    Method *-- "1" Modifier
    End *-- "1" EndType : type
    Relationship *-- "1" RelationshipType : type

    AbstractVisitor -right-> ModelElement : visits

    Parser *-up- "1" peg_parser.SyntaxTree
    Parser *-up- "1" peg_parser.ParserGenerator
}

' TODO: go for Translator -> PostProcessor -> CodeGenerator

namespace Cpp {

    namespace Class {
        ' *************** ALGORITHMS ***************
        class PostProcessor {
            +process(vector<Class> classes)
        }

        class IncludeGatherer {
            +gather(Class& c)
        }
        class IncludeOptimizer {
            +process(vector<Class> classes)
        }
        class MemberSorter {
            +sort(Class& c)
        }

        PostProcessor *-- IncludeGatherer
        PostProcessor *-- IncludeOptimizer
        PostProcessor *--- MemberSorter
        IncludeOptimizer <- IncludeGatherer


        class HeaderGenerator {
            +string generate(Class in)
        }

        class SourceGenerator {
            +string generate(Class in)
        }

        Translator -left-> PostProcessor

        class ClassGenerator implements .Generator {
        }
        ClassGenerator *-- Translator
        ClassGenerator *-- PostProcessor
        ClassGenerator *-- HeaderGenerator
        ClassGenerator *--- SourceGenerator
        
        class Translator 
        {
            +visit(Variable v)     : bool
            +visit(Method m)       : bool
            +visit(Relationship r) : bool
            +visit(Container c)    : bool
            +visit(Element e)      : bool
            +visit(Note n)         : bool
            +visit(Separator s)    : bool
            +visit(Keyword k)      : bool
            +visit(Parameter p)    : bool
            +visit(End e)          : bool

            +results() : vector<Class>
        }
        Translator .|> PlantUml.AbstractVisitor

        ' *************** DATA ***************
        class Class << (S,#FFAA55) >> 
        {
            +name : string
            +comment : string
            +isStruct : bool
            +namespaces : list<string>
            +inherits : set<string>
            +externalIncludes : vector<string>
            +localIncludes : vector<string>
        }
        class ClassElement << (V,#FF55AA) >>
        class VisibilityKeyword << (S,#FFAA55) >> 
        {
            +name : string
        }
        class Separator << (S,#FFAA55) >> 
        {
            +text : string
        }
        class Variable << (S,#FFAA55) >> 
        {
            +name : string
            +comment : string
            +isStatic : bool
        }
        class Method << (S,#FFAA55) >> 
        {
            +name : string
            +comment : string
            +isAbstract : bool
            +isConst : bool
            +isStatic : bool
        }
        class Parameter << (S,#FFAA55) >> 
        {
            +name : string
        }
        class Type << (S,#FFAA55) >> 
        {
            +base : list<string>
            +templateParams : vector<Type>
        }

        Method *-- "1" Type : returnType
        Parameter *-- "1" Type : type
        Variable *-- "1" Type : type


        Class *-- "0..*" ClassElement : body
        ClassElement *-- Method
        ClassElement *-- Variable
        ClassElement *-- VisibilityKeyword
        ClassElement *-- Separator
        Method *-- "0..*" Parameter : parameters


        ' class Enum {
        '     +name  : string
        '     +namespaces : list<string>
        '     +comment : string
        ' }
        ' class Keyword {
        '     +name : string
        ' }

        ' Enum *-- Keyword


        ' class Variant {
        '     +name  : string
        '     +namespaces : list<string>
        '     +comment : string
        ' }

        ' Variant *-- "1..*" Type : containedTypes
    }

}

@enduml